# Challenge 7

## Search for secrets

### Github Advanced Security

1. Follow the steps in [Enabling secret scanning for private repositories](https://docs.github.com/en/code-security/secret-scanning/configuring-secret-scanning-for-your-repositories)
1. Follow the steps in [Manage secret alerts](https://docs.github.com/en/code-security/secret-scanning/managing-alerts-from-secret-scanning)

### Gitleaks

One of the sample solutions (`workflow.pr.api.poi.gitleaks.yml`) is using a 3rd party extension called [Gitleaks](https://github.com/zricethezav/gitleaks) to look for credentials and secrets in code.

To make the process easier, a [GitHub Action](https://github.com/marketplace/actions/gitleaks-scanner) was provided, which encapsulates the call to `gitleaks`. This is an alternative to the ["official" Gitleaks action](https://github.com/marketplace/actions/gitleaks), which doesn't offer as many configuration options.

Configuring the Action with `fail: true` ensures that the workflow stops if secrets are found in code. This happens before actually building the application.

For repositories with **GitHub Advanced Security** there's also the option to publish the SARIF report generated by the Gitleaks scanner.

### Custom rules in TOML

The recommended GitHub Action already has [CredScan rules](https://github.com/jessehouwing/gitleaks-azure/blob/main/UDMSecretChecks.toml) baked into it, so it doesn't need additional configuration in order to work. However, while the default ruleset is able to catch the most common secret types, it might be beneficial to create custom rules as well. As an example, a simple Azure Storage Connection String detection would look like this:

```toml
[[rules]]
  description = "Azure Storage Connection String"
  regex = '''DefaultEndpointsProtocol=http[s]?;AccountName=(.+);AccountKey=(.+)==;'''
```

## Secret rotation

Secret rotation is automated using [Automate the rotation of a secret for resources that use one set of authentication credentials](https://docs.microsoft.com/en-us/azure/key-vault/secrets/tutorial-rotation) which covers exactly our case of automated SQL Server password change.

Full solution is provided in the `support/sqlsecretrotation` folder and it expects to find a Key Vault in the main resource group and SQL-PASSWORD secret with specific metadata (tags).

> The required secret tags are:
>
> * `CredentialId` - SQL admin username
> * `ProviderAddress` - resource ID of the SQL Database instance
> * `ValidityPeriodDays` - for how long should the secret stay valid

Teams can create it manually in the portal, but in the spirit of DevOps, they should modify the IaC code and include the Key Vault and secret population there. To make things smoother the Key Vault provisioning code is already present in `iac/bicep` and `iac/terraform` files.

For testing, it's a good idea to enable your account in Key Vault access policies, to be able to see secrets:

```bash
az keyvault set-policy --upn <username of the user> --name <keyvault name> --secret-permissions set delete get list
```

Individual App Services need to be modified to:

1. Have a managed identity
1. Add this identity to Key Vault access policies
1. Load secrets automatically from Key Vault, using references in application settings

These changes are by default commented out in the Bicep/Terraform IaC definitions.

Correctly configured Key Vault references should have a green tick "✔️ Key vault Reference" in the Web App's settings.
